# 极客时间

![image-20221219141644234](C:\Users\97000\Desktop\春招\笔记\assets\image-20221219141644234.png)

## 1 数组&链表

Array&Linked List。

### 1.1 数组

- 访问：O(1)
  - 数组使用内存管理器实现按下标访问元素。

![image-20221217115429914](C:\Users\97000\Desktop\春招\笔记\assets\image-20221217115429914.png)

- 插入/删除：O(N)

![image-20221217115651398](C:\Users\97000\Desktop\春招\笔记\assets\image-20221217115651398.png)

### 1.2 链表

单链表：

![image-20221217115815230](C:\Users\97000\Desktop\春招\笔记\assets\image-20221217115815230.png)

插入：

![image-20221217194859066](C:\Users\97000\Desktop\春招\笔记\assets\image-20221217194859066.png)

删除同理，只需要改变两次next指针，所以复杂度是O(1)。

但链表查找的时间复杂度是O(N)。

双链表：

![image-20221217195030435](C:\Users\97000\Desktop\春招\笔记\assets\image-20221217195030435.png)

### 1.3 练习

#### 206 反转链表

#### 24 两两交换链表中的节点

#### 141 有环链表

## 2 堆栈&队列

Stack：First in last out。

Queue：First in first out。

### 2.1 堆栈

![image-20221219141454830](C:\Users\97000\Desktop\春招\笔记\assets\image-20221219141454830.png)

### 2.2 队列

![image-20221219141603565](C:\Users\97000\Desktop\春招\笔记\assets\image-20221219141603565.png)



### 2.3 优先队列

PriorityQueue。

正常入，按照优先级出。

#### 2.3.1 实现机制

- Heap（堆
- Binary Search Tree（二叉搜索树

#### 2.3.2 Mini Heap（小顶堆

最小的元素在最上面。

![image-20221229232956926](C:\Users\97000\Desktop\春招\笔记\assets\image-20221229232956926.png)

#### 2.3.3 Max Heap（大顶堆

最大的元素在最上面。

![image-20221229233120870](C:\Users\97000\Desktop\春招\笔记\assets\image-20221229233120870.png)

### 2.4 双向队列

LinkedList。

```c#
LinkedList<int> list = new LinkedList<int>();
list.AddFirst();
Console.WriteLine(list.First.Value);
list.RemoveFirst();
list.AddLast();
...
```

### 2.5 练习

#### 20 有效的括号

#### 225 用队列实现栈

```c#
public class MyStack {
    Queue<int> queueA;
    Queue<int> queueB;

    public MyStack() {
        queueA = new Queue<int>();  //栈内元素
        queueB = new Queue<int>();  //倒换工具
    }
    
    public void Push(int x) {
        queueB.Enqueue(x);
        while(queueA.Count!=0){
            queueB.Enqueue(queueA.Dequeue());
        }
        Queue<int> queue = queueA;
        queueA = queueB;
        queueB = queue;
    }
    
    public int Pop() {
        return queueA.Dequeue();
    }
    
    public int Top() {
        return queueA.Peek();
    }
    
    public bool Empty() {
        return !queueA.Any();
    }
}
```

#### 232 用栈实现队列

```c#
public class MyQueue {
    Stack<int> stackA;
    Stack<int> stackB;

    public MyQueue() {
        stackA = new Stack<int>(); 
        stackB = new Stack<int>();
    }
    
    public void Push(int x) {
        stackA.Push(x);
    }
    
    public int Pop() {
        if(stackB.Count==0){
            while(stackA.Count!=0){
                stackB.Push(stackA.Pop());
            }
        }
        return stackB.Pop();
    }
    
    public int Peek() {
        if(stackB.Count==0){
            while(stackA.Count!=0){
                stackB.Push(stackA.Pop());
            }
        }
        return stackB.Peek();
    }
    
    public bool Empty() {
        if(stackA.Count==0&&stackB.Count==0) return true;
        return false;
    }
}
```

#### 703 数据流中的第K大元素（PriorityQueue

```c#
public class KthLargest {
    PriorityQueue<int,int> queue = new PriorityQueue<int,int>();
    int num;
    public KthLargest(int k, int[] nums) {
        num = k;
        for(int i=0;i<nums.Length;i++) queue.Enqueue(nums[i],nums[i]);
    }
    
    public int Add(int val) {
        queue.Enqueue(val,val);
        while(queue.Count!=num){
            queue.Dequeue();
        }
        return queue.Peek();
    }
}
```

#### 239 滑动窗口最大值（LinkedList

```c#
public class Solution {
    public int[] MaxSlidingWindow(int[] nums, int k) {
        //初始化
        int[] result = new int[nums.Length-k+1];
        int num = 0;
        LinkedList<int> list = new LinkedList<int>();
        for(int i=0;i<nums.Length;i++){
            if(i>=k&&list.First.Value==nums[i-k]) list.RemoveFirst();
            while(list.Count!=0&&list.Last.Value<nums[i]) list.RemoveLast();
            list.AddLast(nums[i]);
            if(i>=k-1) result[num++] = list.First.Value;
        }
        return result;
    }
}
```

## 3 哈希表&字典

HashTable&Dictionary。

### 3.1 哈希表（散列表

哈希表会使用哈希函数将被查找的键转化为数组的索引，在理想的状态下，不同的键会被转化为不同的索引值，但实践中经常会出现不同的键生成相同的索引的情况，称为“哈希冲突”。

#### 3.1.1 哈希冲突

##### 1 拉链法

![img](C:\Users\97000\Desktop\春招\笔记\assets\70.png)

将数组的每一个元素指向一个链表，将发生哈希冲突的元素存储在对应数组元素指向的链表中。

该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希表实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表的顺序找到相应的键。

##### 2 开放寻址法

**线性探测法**是开放寻址法中最简单的方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位来解决碰撞冲突。

![img](C:\Users\97000\Desktop\春招\笔记\assets\70-1672391300244-3.png)

当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查表中下一个位置。
于拉链法，查找的效率在于链表的长度，一般我们应该保证长度的M/8-M/2之间，如果链表的长度大于M/2，我们可以扩充数组长度。如果长度在0~M/8时，我们可以缩短数组的长度。对于线性探索法，动态调整数组的大小需要对所有的值重新进行散列并插入新的表中。

#### 3.1.2 哈希碰撞攻击

我们知道如果哈希函数选择不当会使大量的键都会映射到相同的索引上，不管是采用拉链法还是开放寻址法解决冲突，在后面查找的时候都需要进行多次探测或者查找，在很多时候会使得哈希表的查找效率退化，而不再是常数时间。

哈希攻击就是通过精心构造哈希函数，使得所有的键进过函数函数后都会映射到同一个或者几个索引上，将哈希表退化为一个单链表，这样哈希表的各种操作，比如插入、查找都会从O(1)退化到了链表的查找操作，这样会消耗大量的CPU资源，导致系统无法响应，从而达到拒绝服务供给（Denial of Service,DOS）的目的。
![img](C:\Users\97000\Desktop\春招\笔记\assets\70-1672391493730-6.png)

### 3.2 HashTable Vs Dictionary

#### 3.2.1 HashTable

HashTable中的键值都是object类型，支持所有类型的键值对，在声明时不需要对键值指定类型。

```c#
using System.Collections.Generic;
Hashtable hstable = new Hashtable();
//添加数据
hstable.Add(1,"2");
hstable.Add("a",true);
//删除数据
hstable.Remove("a");
//判断是否存在key值|value值
bool t = hstable.ContainsKey("a");
bool i = hstable.ContainsValue(true);
//遍历哈希表
foreach(DictionaryEntry item in hstable){
	Debug.Log(item.key+" "+item.Value);
}
```

#### 3.2.2 Dictionary

hashtable不支持泛型，dictionary支持泛型。

```c#
Dictionary<int,int> dict = new Dictionary<int,int>();
//添加数据
dict.Add(key,value);
//删除数据
dict.Remove(key);
//判断是否存在
bool x = dict.ContainsKey(key);
bool y = dict.ContainsValue(value);
//清空
dict.Clear();
//遍历字典
foreach(var d in dict){
	Console.WriteLine(d.Key);
    Console.WriteLine(d.Value);
}
```

#### 3.2.3 对比

- 泛型
  - 哈希表不支持泛型，字典支持泛型。
- 元素类型
  - 哈希表的元素属于object类型，所以在存储和检索时经常发生装箱拆箱操作。
- 多线程区别
  - 单线程用字典，有泛型优势，读取速度快，容量利用更充分。
  - 默认哈希表允许单线程写入，多线程读取。
- 线程安全
  - 字典非线程安全，必须人为增加lock语句进行保护，影响效率。
  - 哈希表可以调用Synchronized()方法可以获得完全线程安全的类型。
- 数据插入顺序
  - 字典的排序就是按照插入的顺序排序（删除节点后就被打乱了），因此在需要体现顺序的情况下，字典更有效。
- 索引效率
  - 字典在单线程索引数据的时候效率比较高，读取速度快，但数据量大的时候效率会下降。
  - 哈希表的索引方式是经过散列处理的，在数据量大的时候处理效率更高，所以哈希表比较适合运用在做对象缓存，树递归算法的替代等各种需要提升效率的场合。
  - 在通过代码测试的时候发现key是整数型dictionary的效率比hashtable快，如果key是字符串型，dictionary的效率比hashtable快。

### 3.3 练习

#### 242 有效的字母异位词

##### 字典

```c#
public class Solution {
    public bool IsAnagram(string s, string t) {
        if(s.Length!=t.Length) return false;
        Dictionary<char,int> dict = new Dictionary<char,int>();
        for(int i=0;i<s.Length;i++){
            if(!dict.ContainsKey(s[i])) dict.Add(s[i],1);
            else dict[s[i]] = dict[s[i]]+1;
        } 
        for(int i=0;i<t.Length;i++){
            if(!dict.ContainsKey(t[i])) return false;
            else{
                dict[t[i]] = dict[t[i]]-1;
                if(dict[t[i]]<0) return false;
            }
        }
        return true;
    }
}
```

##### 字符串排序对比

```c#
public class Solution {
    public bool IsAnagram(string s, string t) {
        if(s.Length!=t.Length) return false;
        char[] str1 = s.ToCharArray();
        char[] str2 = t.ToCharArray();
        Array.Sort(str1);
        Array.Sort(str2);
        return str1.SequenceEqual(str2);
    }
}
```

PS：Array.Equals(str1,str2)是通过比较引用来检查两数组是否相同。

#### 1 两数之和

```c#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int,int> dict = new Dictionary<int,int>();
        int[] result = new int[2];
        for(int i=0;i<nums.Length;i++){
            if(dict.ContainsKey(target-nums[i])){
                result[0] = i;
                result[1] = dict[target-nums[i]];
                return result;
            }else{
                if(!dict.ContainsKey(nums[i])){
                    dict.Add(nums[i],i);
                }
            }
        }
        return result;
    }
}
```

#### 15 三数之和

排序+双指针

```c#
public class Solution {
    public IList<IList<int>> ThreeSum(int[] nums) {
        //第一步：排序+初始化
        IList<IList<int>> list = new List<IList<int>>();
        Array.Sort(nums);
        //第二步：指针
        for(int i=0;i<nums.Length;i++){
            if(i>0&&nums[i]==nums[i-1]) continue;
            if(nums[i]>0) return list;
            int x = i+1;
            int y = nums.Length-1;
            while(x<y){
                if(nums[i]+nums[x]+nums[y]==0){
                    if(i!=x&&x!=y){
                        List<int> temp = new List<int>();
                        temp.Add(nums[i]);
                        temp.Add(nums[x]);
                        temp.Add(nums[y]);
                        list.Add(temp);
                    }
                    x++;
                    y--;
                }
                else if(nums[i]+nums[x]+nums[y]<0) x++;
                else if(nums[i]+nums[x]+nums[y]>0) y--;
                while(x>i+1&&x<nums.Length&&nums[x]==nums[x-1]) x++;
                while(y<nums.Length-1&&y>=0&&nums[y]==nums[y+1]) y--;
            }
        }
        return list;
    }
}
```

#### 18 四数之和

三数之和的基础上加上一层循环

```c#
public class Solution {
    public IList<IList<int>> FourSum(int[] nums, int target) {
        IList<IList<int>> list = new List<IList<int>>();
        if(nums.Length<4) return list;
        Array.Sort(nums);
        for(int i=0;i<nums.Length-3;i++){
            if(i>0&&nums[i]==nums[i-1]) continue;
            for(int j=i+1;j<nums.Length-2;j++){
                if(j>i+1&&nums[j]==nums[j-1]) continue;
                if((long)nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;
                int x = j+1;
                int y = nums.Length-1;
                while(x<y){
                    if((long)nums[i]+nums[j]+nums[x]+nums[y]==target){
                        List<int> temp = new List<int>();
                        temp.Add(nums[i]);
                        temp.Add(nums[j]);
                        temp.Add(nums[x]);
                        temp.Add(nums[y]);
                        list.Add(temp);
                        x++;
                        y--;
                    }
                    else if(nums[i]+nums[j]+nums[x]+nums[y]<target) x++;
                    else if(nums[i]+nums[j]+nums[x]+nums[y]>target) y--;
                    while(x>j+1&&x<nums.Length&&nums[x]==nums[x-1]) x++;
                    while(y<nums.Length-1&&y>=0&&nums[y]==nums[y+1]) y--;
                }
            }
        }
        return list;
    }
}
```

## 4 二叉树

### 4.1 概念

- 每个节点最多有两棵子树
- 二叉树的子树有左右之分，不可颠倒

### 4.2 特殊二叉树

- 满二叉树
  - 一个二叉树每一层的结点数都达到最大值
- 完全二叉树
  - 完全二叉树相比满二叉树，仅要求最后一层外的节点数达到最大值，因此可以把满二叉树看成是特殊的完全二叉树

![img](C:\Users\97000\Desktop\春招\笔记\assets\d790444f0801485f98eb4397631eb29c.png)

- 二叉搜索树
  - 也称有序二叉树，排序二叉树，是指一棵空树或者具有下列性质的二叉树
    - 左子树上所有结点的值均小于它的根结点的值
    - 右子树上所有结点的值均大于它的根节点的值

### 4.3 练习

#### 98 验证二叉搜索树

```c#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public bool temp;
    public bool IsValidBST(TreeNode root) {
        temp = true;
        DFS(root,-10000000000,10000000000);
        return temp;
    }
    public void DFS(TreeNode root,long down,long up){
        if(!temp) return;
        if(root.left==null&&root.right==null) return;
        if(root.left!=null){
            if(root.left.val<root.val&&root.left.val>down){
                DFS(root.left,down,Math.Min(up,root.val));
            }else{
                temp = false;
            }
        }
        if(root.right!=null){
            if(root.right.val>root.val&&root.right.val<up){
                DFS(root.right,Math.Max(down,root.val),up);
            }else{
                temp = false;
            }
        }
    }
}
```

#### 235 二叉搜索树的最近公共祖先

```c#
public class Solution {
    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode x, TreeNode y) {
        while(true){
            if(x.val<root.val&&y.val<root.val) root = root.left;
            else if(x.val>root.val&&y.val>root.val) root = root.right;
            else return root;
        }
        return null;
    }
}
```

#### 236 二叉树的最近公共祖先

```c#
public class Solution {
    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null||root==p||root==q) return root;
        TreeNode left = LowestCommonAncestor(root.left,p,q);
        TreeNode right = LowestCommonAncestor(root.right,p,q);
        if(left==null) return right;
        if(right==null) return left;
        return root;
    }
}
```

#### 94 二叉树的中序遍历

##### 递归

```c#
public class Solution {
    public IList<int> list;
    public IList<int> InorderTraversal(TreeNode root) {
        list = new List<int>();
        if(root==null) return list;
        DFS(root);
        return list;
    }
    private void DFS(TreeNode root){
        if(root.left==null&&root.right==null){
            list.Add(root.val);
            return;
        }
        if(root.left!=null) DFS(root.left);
        list.Add(root.val);
        if(root.right!=null) DFS(root.right);
    }
}
```

##### 迭代（栈

```c#
public class Solution {
    public IList<int> InorderTraversal(TreeNode root) {
        IList<int> list = new List<int>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(root!=null||stack.Count!=0){
            while(root!=null){
                stack.Push(root);
                root = root.left;
            }
            root = stack.Pop();
            list.Add(root.val);
            root = root.right;
        }
        return list;
    }
}
```

#### 102 二叉树的层序遍历

##### 迭代（队列

```c#
public class Solution {
    public IList<IList<int>> LevelOrder(TreeNode root) {
        IList<IList<int>> list = new List<IList<int>>();
        if(root==null) return list;
        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        while(queue.Count!=0){
            int num = queue.Count;
            List<int> temp = new List<int>();
            while(num>0){
                TreeNode node = queue.Dequeue();
                temp.Add(node.val);
                if(node.left!=null) queue.Enqueue(node.left);
                if(node.right!=null) queue.Enqueue(node.right);
                num--;
            }
            list.Add(temp);
        }
        return list;
    }
}
```

#### 144 二叉树的前序遍历

##### 递归

```c#
public class Solution {
    public IList<int> list;
    public IList<int> PreorderTraversal(TreeNode root) {
        list = new List<int>();
        if(root==null) return list;
        DFS(root);
        return list;
    }
    private void DFS(TreeNode root){
        list.Add(root.val);
        if(root.left==null&&root.right==null) return;
        if(root.left!=null) DFS(root.left);
        if(root.right!=null) DFS(root.right);
    }
}
```

##### 迭代（栈

```c#
public class Solution {
    public IList<int> PreorderTraversal(TreeNode root) {
        IList<int> list = new List<int>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.Push(root);
        while(stack.Count!=0){
            TreeNode node = stack.Pop();
            list.Add(node.val);
            if(node.right!=null) stack.Push(node.right);
            if(node.left!=null) stack.Push(node.left);
        }
        return list;
    }
}
```

#### 145 二叉树的后序遍历

##### 递归

```c#
public class Solution {
    public IList<int> list;
    public IList<int> PostorderTraversal(TreeNode root) {
        list = new List<int>();
        if(root==null) return list;
        DFS(root);
        return list;
    }
    private void DFS(TreeNode root){
        if(root.left==null&&root.right==null){
            list.Add(root.val);
            return;
        }
        if(root.left!=null) DFS(root.left);
        if(root.right!=null) DFS(root.right);
        list.Add(root.val);
    }
}
```

##### 迭代（栈

```c#
public class Solution {
    public IList<int> PostorderTraversal(TreeNode root) {
        IList<int> list = new List<int>();
        if(root==null) return list;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(root!=null||stack.Count!=0){
            while(root!=null){
                stack.Push(root);
                root = root.left;
            }
            root = stack.Peek();
            if(root.right==null||(list.Count!=0&&root.right.val==list[list.Count-1])){
                list.Add(stack.Pop().val);
                root = null;
            }else{
                root = root.right;
            }
        }
        return list;
    }
}
```

## 5 递归&分治

### 5.1 递归

递归是一种通过函数体自我调用实现的循环。

PS：递归和DFS（递归是一种算法结构，回溯是一种算法思想，DFS是回溯搜索的一种）。

### 5.2 分治

把一个大问题分成很多个子问题，然后对子问题一一进行分析。

### 5.3 练习

#### 50 Pow(x,n)

计算x的整数n次幂。

##### 分治

```c#
public class Solution {
    public double MyPow(double x, int n) {
        return n>0? Method(x,n):1/Method(x,-(long)n);
    }
    public double Method(double x,long n){
        if(n==0) return 1;
        if(n%2!=0) return x*Method(x,n-1);
        double y = Method(x,n/2);
        return y*y;
    }
}
```

##### 二进制位运算

```c#
public class Solution {
    public double MyPow(double x, int n) {
        long b = n;
        if(b<0){
            b = -b;
            x = 1/x;
        }
        double res = 1;
        while(b>0){
            if((b&1)==1) res*=x;
            x*=x;
            b>>=1;
        }
        return res;
    }
}
```

#### 169 多数元素

##### 排序

位于nums.Length/2下标的数一定是众数。

```c#
public class Solution {
    public int MajorityElement(int[] nums) {
        Array.Sort(nums);
        return nums[nums.Length/2];
    }
}
```

##### 抵消法

多数元素的数量比其他所有元素的总数还多，那么多数元素的数量可以抵消其他所有元素的数量。

从前往后遍历，遇到相同元素，计数 +1 ，遇到不同元素，计数-1，当旧数的出现次数减到0，新数替换旧数。直至遍历完成，最终剩下的那个数，就是多数元素。

```c#
public class Solution {
    public int MajorityElement(int[] nums) {
        int n=0;
        int m=0;
        for(int i=0;i<nums.Length;i++){
            if(n==0){
                n++;
                m=nums[i];
            }else{
                if(m==nums[i]) n++;
                else n--;
            }
        }
        return m;
    }
}
```

## 6 贪心算法

### 6.1 概念

Greedy。

指的是在对问题求解时，总是做出在当前看来是最好的选择。

![image-20230101020051066](C:\Users\97000\Desktop\春招\笔记\assets\image-20230101020051066.png)

每次都选最大的面值。

但按照贪心法其实并不一定能得到正确的答案。

适用贪心算法的场景：

问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

### 6.2 练习

#### 122 买卖股票的最佳时机Ⅱ

贪心算法

每一天都买进并卖出昨天的，如果是正数，那么加入利润。

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        int res = 0;
        for(int i=1;i<prices.Length;i++){
            int temp = prices[i]-prices[i-1];
            if(temp>0) res+=temp;
        }
        return res;
    }
}
```

动态规划

定义状态dp[i] [0]表示第i天交易完后手里没有股票的最大利润，dp[i] [1]表示第i天交易完后手里有股票的最大利润。

考虑dp[i] [0]的转移方程，此时手里没有股票，那么有两种情况，前一天持有今天卖掉了或者是前一天也没有持有。

即：dp[i] [0] = Math.Max(dp[i-1] [0],dp[i-1] [1]+prices[i])。

考虑dp[i] [1]的转移方程，此时手里持有股票，那么有两种情况，前一天持有且今天没有卖掉或者前一天没有持有今天买入。

即：dp[i] [1] = Math.Max(dp[i-1] [0]-prices[i],dp[i-1] [1])。

初始状态：

dp[0] [0] = 0,dp[0] [1] = -prices[0]。

最后答案即为dp[n-1] [0]。

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        int[,] dp = new int[prices.Length,2];
        dp[0,0] = 0;
        dp[0,1] = -prices[0];
        for(int i=1;i<prices.Length;i++){
            dp[i,0] = Math.Max(dp[i-1,0],dp[i-1,1]+prices[i]);
            dp[i,1] = Math.Max(dp[i-1,0]-prices[i],dp[i-1,1]);
        } 
        return dp[prices.Length-1,0];
    }
}
```

## 7 DFS&BFS

### 7.1 概念

![image-20230101051747144](C:\Users\97000\Desktop\春招\笔记\assets\image-20230101051747144.png)

### 7.2 练习

#### 104 二叉树的最大深度

DFS

```c#
public class Solution {
    public int res;
    public int MaxDepth(TreeNode root) {
        res = 0;
        if(root==null) return res;
        DFS(root,0);
        return res;
    }
    private void DFS(TreeNode root,int dep){
        dep++;
        if(root.left==null&&root.right==null){
            res = Math.Max(res,dep);
            return;
        }
        if(root.left!=null) DFS(root.left,dep);
        if(root.right!=null) DFS(root.right,dep);
    }

}
```

#### 111 二叉树的最小深度

```c#
public class Solution {
    public int res;
    public int MinDepth(TreeNode root) {
        res = 100000;
        if(root==null) return 0;
        DFS(root,0);
        return res;
    }
    private void DFS(TreeNode root,int dep){
        dep++;
        if(dep>=res) return;
        if(root.left==null&&root.right==null) res = dep;
        if(root.left!=null) DFS(root.left,dep);
        if(root.right!=null) DFS(root.right,dep);
    }
}
```

#### 22 括号生成

```c#
public class Solution {
    public IList<string> list;
    public int num;
    public IList<string> GenerateParenthesis(int n) {
        list = new List<string>();
        num = n;
        if(n==0) return list;
        DFS("",0,0);
        return list;
    }
    private void DFS(String str,int left,int right){
        if(left==num&&right==num){
            list.Add(str);
            return;
        }
        if(left<num) DFS(str+"(",left+1,right);
        if(right<left) DFS(str+")",left,right+1);
    }
}
```

## 8 剪枝

### 8.1 概念

略。

### 8.2 练习

#### 51 N皇后

```c#
public class Solution {
    public IList<IList<string>> list;
    public int num;
    public IList<IList<string>> SolveNQueens(int n) {
        list = new List<IList<string>>();
        num = n;
        if(n==0) return list;
        int[] col = new int[n];
        int[] fro = new int[n*2-1];
        int[] rev = new int[n*2-1];
        Method(col,fro,rev,0,"");
        return list;
    }
    private void Method(int[] col,int[] fro,int[] rev,int n,string str){
        if(n==num){
            ToList(str);
            return;
        }
        for(int i=0;i<num;i++){
            if(col[i]==0&&fro[i+n]==0&&rev[i-n+num-1]==0){
                col[i]=1;
                fro[i+n]=1;
                rev[i-n+num-1]=1;
                Method(col,fro,rev,n+1,str+i.ToString()+",");
                col[i]=0;
                fro[i+n]=0;
                rev[i-n+num-1]=0;
            }
        }
    }
    private void ToList(string str){
        string[] temp = str.Split(",");
        List<string> l = new List<string>();
        for(int i=0;i<num;i++){
            String res = "";
            int x = int.Parse(temp[i]);
            int b = 0;
            while(b<num){
                if(b!=x) res = res+".";
                else res = res+"Q";
                b++;
            }
            l.Add(res);
        }   
        list.Add(l);
    }
}
```

#### 52 N皇后Ⅱ

```c#
public class Solution {
    public int num;
    public int res;
    public int TotalNQueens(int n) {
        if(n==0) return 0;
        num = n;
        res = 0;
        int[] col = new int[n];
        int[] fro = new int[n*2-1];
        int[] rev = new int[n*2-1];
        Method(col,fro,rev,0);
        return res;
    }
    private void Method(int[] col,int[] fro,int[] rev,int n){
        if(n==num){
            res++;
            return;
        }
        for(int i=0;i<num;i++){
            if(col[i]==0&&fro[i+n]==0&&rev[i-n+num-1]==0){
                col[i]=1;
                fro[i+n]=1;
                rev[i-n+num-1]=1;
                Method(col,fro,rev,n+1);
                col[i]=0;
                fro[i+n]=0;
                rev[i-n+num-1]=0;
            }
        }
    }
}
```

#### 36 有效的数独

```c#
public class Solution {
    public bool IsValidSudoku(char[][] board) {
        bool[,] row = new bool[9,10];  //第几行数字几是否出现
        bool[,] col = new bool[9,10];  //第几行数字几是否出现
        bool[,] lat = new bool[9,10];  //第几个格子数字几是否出现
        for(int i=0;i<board.Length;i++){
            for(int j=0;j<board[0].Length;j++){
                if(board[i][j]!='.'){
                    int n = board[i][j]-'0';
                    if(row[i,n]||col[j,n]||lat[Number(i,j),n]) return false;
                    else{
                        row[i,n] = true;
                        col[j,n] = true;
                        lat[Number(i,j),n] = true;
                    }
                }
            }
        }
        return true;
    }
    private int Number(int i,int j){
        if(i<3){
            if(j<3) return 0;
            if(j>=3&&j<6) return 1;
            if(j>=6) return 2;
        }else if(i>=3&&i<6){
            if(j<3) return 3;
            if(j>=3&&j<6) return 4;
            if(j>=6) return 5;
        }else if(i>=6){
            if(j<3) return 6;
            if(j>=3&&j<6) return 7;
            if(j>=6) return 8;
        }
        return -1;
    }
}
```

#### 37 解数独

```c#
public class Solution {
    public char[][] res;
    public void SolveSudoku(char[][] board) {
        //初始化状态      
        res = board;
        bool[,] row = new bool[9,10];  //第几行数字几是否出现
        bool[,] col = new bool[9,10];  //第几行数字几是否出现
        bool[,] lat = new bool[9,10];  //第几个格子数字几是否出现
        for(int i=0;i<board.Length;i++){
            for(int j=0;j<board[0].Length;j++){
                if(board[i][j]!='.'){
                    int n = board[i][j]-'0';
                    row[i,n] = true;
                    col[j,n] = true;
                    lat[Number(i,j),n] = true;
                }
            }
        }
        //填入数字
        DFS(0,0,row,col,lat,board);
        board = res;
    }
    //方法1：DFS找答案
    //每一行依次搜索
    private bool DFS(int i,int j,bool[,] row,bool[,] col,bool[,] lat,char[][] board){
        if(i==9){
            res = board;
            return true;
        }
        if(j==9){
            return DFS(i+1,0,row,col,lat,board);
        }
        if(board[i][j]=='.'){
            for(int k=1;k<=9;k++){
                if(!row[i,k]&&!col[j,k]&&!lat[Number(i,j),k]){
                    row[i,k] = true;
                    col[j,k] = true;
                    lat[Number(i,j),k] = true;
                    board[i][j] = (char)(k+'0');
                    if(DFS(i,j+1,row,col,lat,board)){
                        return true;
                    }
                    row[i,k] = false;
                    col[j,k] = false;
                    lat[Number(i,j),k] = false;
                    board[i][j] = '.';
                }
            }
        }else{
            return DFS(i,j+1,row,col,lat,board);
        }
        return false;
    }
    //方法2：判断位于哪个3x3宫格，0-8
    private int Number(int i,int j){
        if(i<3){
            if(j<3) return 0;
            if(j>=3&&j<6) return 1;
            if(j>=6) return 2;
        }else if(i>=3&&i<6){
            if(j<3) return 3;
            if(j>=3&&j<6) return 4;
            if(j>=6) return 5;
        }else if(i>=6){
            if(j<3) return 6;
            if(j>=3&&j<6) return 7;
            if(j>=6) return 8;
        }
        return -1;
    }
}
```

## 9 二分查找

### 8.1 概念

适合二分查找的场景（数组就挺适合的

- 单调递增或递减
- 存在上下界
- 能够通过索引访问

### 8.2 练习

#### 69 x的平方根

##### 二分查找

```c#
class Solution {
    public int MySqrt(int x) {
        int a=0, b=x, res=0;
        while (a<=b) {
            int mid = a+(b-a)/2;
            if((long)mid*(long)mid==x) return mid;
            else if((long)mid*(long)mid<x){
                res = mid;
                a = mid+1;
            }else b = mid-1;
        }
        return res;
    }
}
```

##### 牛顿迭代法

牛顿迭代法是用来求解方程根的，通过不断地枚举新的数逼近真根。

公式为：
$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$
该题目中，我们的$f(x_n)=x_n^2-C$，C为要求平方根的正整数。

代入原式子：
$$
x_{n+1} = x_n - \frac{x_n^2-C}{2xn}=\frac{x_n+C/x_n}{2}
$$
所以该题的迭代式如上。

```c#
public class Solution {
    public int MySqrt(int x) {
        long res = x;
        while(res*res>x){
            res = (res+x/res)/2;
        }
        return (int)res;
    }
}
```

## 10 字典树

Trie树，又称单词查找树或键树。

### 10.1 概念

用途：经常被搜索引擎系统用于词频推荐。

![image-20230101185420219](C:\Users\97000\Desktop\春招\笔记\assets\image-20230101185420219.png)

结点无含义，边存储字符。

用空间换时间，利用字符串的公共前缀降低查询时间的开销以达到提高效率的目的。

### 10.2 练习

#### 208 实现Trie（前缀树

```c#
public class Trie {
    Trie[] son;
    bool isEnd;
    public Trie() {
        son = new Trie[26];
        isEnd = false;
    }
    
    public void Insert(string word) {
        Trie node = this;
        for(int i=0;i<word.Length;i++){
            int n = word[i]-'a';
            if(node.son[n]==null){
                Trie temp = new Trie();
                node.son[n] = temp;
            }
            node = node.son[n];
        }
        node.isEnd = true;
    }
    
    public bool Search(string word) {
        Trie node = this;
        for(int i=0;i<word.Length;i++){
            int n = word[i]-'a';
            if(node.son[n]==null) return false;
            else node = node.son[n];
        }
        if(node.isEnd) return true;
        return false;
    }
    
    public bool StartsWith(string prefix) {
        Trie node = this;
        for(int i=0;i<prefix.Length;i++){
            int n = prefix[i]-'a';
            if(node.son[n]==null) return false;
            else node = node.son[n];
        }
        return true;
    }
}
```

#### 212 单词搜索Ⅱ

字典树

## 11 位运算

### 11.1 概念

![image-20230102144954351](C:\Users\97000\Desktop\春招\笔记\assets\image-20230102144954351.png)

![image-20230102145116166](C:\Users\97000\Desktop\春招\笔记\assets\image-20230102145116166.png)

常用的位运算操作

```c#
1)x&1==1 or x&1==0 用来判断奇偶（即二进制的最后一位是否为1
2)x=x&(x-1) 清零最低位的1
eg:101000&100111=100000
3)x&-x 得到最低位的1
eg:-x是取反再加1
```

### 11.2 练习

#### 191 位1的个数

位运算1

```c#
public class Solution {
    public int HammingWeight(uint n) {
        int res = 0;
        while(n>0){
            res+=(int)(n&1);
            n>>=1;
        }
        return res;
    }
}
```

位运算2

```c#
public class Solution {
    public int HammingWeight(uint n) {
        int res = 0;
        while(n!=0){
            n &= n-1;
            res++;
        }
        return res;
    }
}
```

#### 231 2的幂

```c#
public class Solution {
    public bool IsPowerOfTwo(int n) {
        return n>0&&(n&(n-1))==0;
    }
}
```

#### 338 比特位计数

```c#
public class Solution {
    public int[] CountBits(int n) {
        int[] res = new int[n+1];
        for(int i=0;i<=n;i++){
            if(i==0) res[i] = 0;
            else if((i&1)==0) res[i] = res[i/2];
            else if((i&1)==1) res[i] = res[i-1]+1;
        }
        return res;
    }
}
```

#### 52 N皇后

```c#
//伪代码
void DFS(row,col,pie,na){
	if(row>=n){count++;return;}
	//获取所有可填空位
	bits = (~(col|pie|na))&((1<<n)-1);
	while(bits>0){
		//获取最低位空位
		p = bits&-bits;
		DFS(row+1,col|p,(pie|p)<<1,(na|p)>>1);
		//去除最低位空位
		bits&bits-1;
	}
}
```

## 12 动态规划

### 12.1 概念

 找状态转移方程。

eg：斐波那契数列。

![image-20230102190355187](C:\Users\97000\Desktop\春招\笔记\assets\image-20230102190355187.png)

递归写法（但有很多重复计算）：

从起始位置出发的可能性等于向下走的可能性和向右走的可能性之和。

```c#
public int Count(bool[][] grid,int row,int col){
	if(!VaildSquare(grid,row,col)) return 0;
	if(isAtEnd(grid,row,col)) return 1;
	return Count(grid,row+1,col) + Count(grid,row,col+1);
}
```

动态规划（递推）：

状态转移方程。

```c#
if(a[i,j]=='空地'):
	opt[i,j] = opt[i-1,j] + opt[i,j-1];
else
	opt[i,j] = 0;
```

DP vs 回溯 vs 贪心

- 回溯（递归）- 重复计算
- 贪心 - 永远局部最优
- DP - 记录局部最优子结构

### 12.2 练习

#### 70 爬楼梯

```c#
public class Solution {
    //dp[n]=dp[n-1]+dp[n-1]
    public int ClimbStairs(int n) {
        if(n==1||n==2) return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3;i<=n;i++){
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

#### 120 三角形的最小路径和

##### 二维数组版本

```c#
public class Solution {
    //dp[i,j]:到第i行第j个结点的最小路径和
    //dp[i,j]=Math.Min(dp[i-1,j-1],dp[i-1,j])+num;
    public int MinimumTotal(IList<IList<int>> triangle) {
        int[,] dp = new int[triangle.Count,triangle.Count+1];
        dp[0,0] = triangle[0][0];
        for(int i=1;i<triangle.Count;i++){
            for(int j=0;j<triangle[i].Count;j++){
                if(j==0) dp[i,j] = dp[i-1,j]+triangle[i][j];
                else if(j==triangle[i].Count-1) dp[i,j] = dp[i-1,j-1]+triangle[i][j];
                else dp[i,j] = Math.Min(dp[i-1,j-1],dp[i-1,j])+triangle[i][j];
            }
        }
        int res = 1000000;
        for(int i=0;i<triangle[triangle.Count-1].Count;i++){
            res = Math.Min(dp[triangle.Count-1,i],res);
        }
        return res;
    }
}
```

##### 空间优化版本

因为dp[i,j]只与dp[i-1,...]有关而和dp[i-2,...]以及之前的无关，所以只需要用一维数组。

```c#
public class Solution {
    public int MinimumTotal(IList<IList<int>> triangle) {
        int[] dp = new int[triangle.Count];
        dp[0] = triangle[0][0];
        for(int i=1;i<triangle.Count;i++){
            int[] temp = new int[triangle.Count];
            for(int j=0;j<triangle[i].Count;j++){
                if(j==0) temp[j] = dp[j]+triangle[i][j];
                else if(j==triangle[i].Count-1) temp[j] = dp[j-1]+triangle[i][j];
                else temp[j] = Math.Min(dp[j-1],dp[j])+triangle[i][j];
            }
            dp = temp;
        }
        int res = 100000;
        for(int i=0;i<triangle.Count;i++){
            res = Math.Min(res,dp[i]);
        }
        return res;
    }
}
```

#### 152 乘积最大子数组

```c#
public class Solution {
    public int MaxProduct(int[] nums) {
        int[] min = new int[nums.Length];
        int[] max = new int[nums.Length];
        min[0] = nums[0];
        max[0] = nums[0];
        for(int i=1;i<nums.Length;i++){
            min[i] = Math.Min(Math.Min(nums[i],min[i-1]*nums[i]),max[i-1]*nums[i]);
            max[i] = Math.Max(Math.Max(nums[i],min[i-1]*nums[i]),max[i-1]*nums[i]);
        }
        int res = max[0];
        for(int i=1;i<max.Length;i++) res = Math.Max(res,max[i]);
        return res;
    }
}
```

#### 300 最长递增子序列

动态规划

```c#
public class Solution {
    public int LengthOfLIS(int[] nums) {
        int[] dp = new int[nums.Length];
        dp[0] = 1;
        int res = 1;
        for(int i=1;i<nums.Length;i++){
            dp[i] = 1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i] = Math.Max(dp[i],dp[j]+1); 
                    res = Math.Max(res,dp[i]); 
                }
            }
        }
        return res;
    }
}
```

#### 322 零钱兑换

动态规划

dp[amount]=min{dp[amount-coins[i]]}+1;

```c#
public class Solution {
    public int CoinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        dp[0] = 0;
        for(int i=1;i<=amount;i++){
            int min = 100000;
            for(int j=0;j<coins.Length;j++){
                int temp = i-coins[j];
                if(temp>=0&&dp[temp]!=-1) min = Math.Min(min,dp[temp]);
            }
            if(min!=100000) dp[i] = min+1;
            else dp[i] = -1;
        }
        return dp[amount];
    }
}
```

#### 72 编辑距离

```c#
public class Solution {
    public int MinDistance(string word1, string word2) {
        //dp[i][j]:word1的前i个字母到word2的前j个字母的编辑距离
        //最后一次操作：
        //1）word1删除(即word2插入)：dp[i][j]=dp[i][j-1]+1;
        //2）word1插入：dp[i][j]=dp[i-1][j]+1;
        //3）word1替换word2：dp[i][j]=dp[i-1][j-1]+1;
        //4）word1和word2最后一个字母相同：dp[i][j]=dp[i-1][j-1];
        //3&4矛盾，二选一
        int[,] dp = new int[word1.Length+1,word2.Length+1];
        for(int i=1;i<=word1.Length;i++) dp[i,0] = i;
        for(int j=1;j<=word2.Length;j++) dp[0,j] = j;
        for(int i=1;i<=word1.Length;i++){
            for(int j=1;j<=word2.Length;j++){
                int a = dp[i,j-1]+1;
                int b = dp[i-1,j]+1;
                int c = dp[i-1,j-1];
                if(word1[i-1]!=word2[j-1]) c++;
                dp[i,j] = Math.Min(Math.Min(a,b),c);
            }
        }
        return dp[word1.Length,word2.Length];
    }
}

```

### 12.3 买卖股票合集

#### 121 买卖股票的最佳时机Ⅰ

买卖一次。

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        //状态：持有/不持有
        //持有：之前买的/刚买的
        //不持有：本来就没有/之前卖的/刚卖的
        int hold = -prices[0];
        int lose = 0;          //代表了一直没有的状态
        for(int i=1;i<prices.Length;i++){
            int a = Math.Max(hold,-prices[i]);
            int b = Math.Max(lose,(hold+prices[i]));
            hold = a;
            lose = b;
        }
        return lose;
    }
}
```

#### 122 买卖股票的最佳时机Ⅱ

买卖无数次。

和买卖一次的区别是hold的前一个状态，买卖一次hold的前一个状态只能是hold或者0，买卖无数次hold的前一个状态可能是lose。

##### 动态规划

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        //状态：持有/不持有
        //持有：本来就有/刚有(前一个状态是没有或卖了)
        //不持有：本来就没有(一直没有或之前卖了)/刚没有
        int hold = -prices[0];
        int lose = 0;           //代表了一直没有的状态
        for(int i=1;i<prices.Length;i++){
            int a = Math.Max(hold,lose-prices[i]);
            int b = Math.Max(lose,hold+prices[i]);
            hold = a;
            lose = b;
        }
        return lose;
    }
}
```

##### 其他算法

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        int res = 0;
        for(int i=1;i<prices.Length;i++){
            if(prices[i]-prices[i-1]>0) res+=(prices[i]-prices[i-1]);
        }
        return res;
    }
}
```

#### 123 买卖股票的最佳时机Ⅲ

买卖两次。

##### 动态规划

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        //dp[state,k] 第一个参数代表状态，第二个参数代表交易次数
        int[,] dp = new int[2,3];     
        for(int i=0;i<3;i++) dp[1,i] = -prices[0];
        for(int i=1;i<prices.Length;i++){
            int[,] temp = new int[2,3];
            for(int j=0;j<3;j++){
                if(j==0) temp[0,j] = 0;
                else temp[0,j] = Math.Max(dp[0,j],(dp[1,j-1]+prices[i]));
                temp[1,j] = Math.Max(dp[1,j],(dp[0,j]-prices[i]));
            }
            dp = temp;
        }   
        int res = dp[0,0];
        for(int i=1;i<3;i++){
            res = Math.Max(res,dp[0,i]);
        }
        return res;
    }
}
```

##### 空间优化版本

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        //四个状态：只进行过一次买操作，完成了一笔交易，完成了一笔交易的前提下又进行了一次买操作，完成了两笔交易
        int buy1 = -prices[0];
        int sell1 = 0;
        int buy2 = -prices[0];
        int sell2 = 0;
        for(int i=1;i<prices.Length;i++){
            buy1 = Math.Max(buy1,-prices[i]);
            sell1 = Math.Max(sell1,buy1+prices[i]);
            buy2 = Math.Max(buy2,sell1-prices[i]);
            sell2 = Math.Max(sell2,buy2+prices[i]);
        }
        return Math.Max(sell1,sell2);
    }
}
```

#### 188 买卖股票的最佳时机Ⅳ

买卖k次。

##### 动态规划

```c#
public class Solution {
    //dp[0,...]：手上无股票 dp[1,...]：手上有股票
    public int MaxProfit(int k, int[] prices) {
        int[,] dp = new int[2,k+1];
        for(int i=0;i<=k;i++) dp[1,i] = -prices[0];
        for(int i=1;i<prices.Length;i++){
            int[,] temp = new int[2,k+1];
            for(int j=0;j<=k;j++){
                if(j==0) temp[0,j] = 0; 
                else temp[0,j] = Math.Max((dp[1,j-1]+prices[i]),dp[0,j]);
                temp[1,j] = Math.Max(dp[1,j],(dp[0,j]-prices[i]));
            }
            dp = temp;
        }
        int res = 0;
        for(int i=0;i<=k;i++){
            res = Math.Max(res,dp[0,i]);
        }
        return res;
    }
}
```

#### 309 最佳买卖股票时机含冷冻期

卖出的后一天不能买入。

```c#
public class Solution {
    public int MaxProfit(int[] prices) {
        int hold = -prices[0];     //持有
        int sell = 0;              //因为卖不持有
        int empty = 0;             //不持有
        for(int i=1;i<prices.Length;i++){
            int a = Math.Max(hold,empty-prices[i]);
            int b = hold+prices[i];
            int c = Math.Max(empty,sell);
            hold = a;
            sell = b;
            empty = c;
        }
        return Math.Max(sell,empty);
    }
}
```

#### 714 买卖股票的最佳时机含手续费

每笔交易支付一次手续费。

```c#
public class Solution {
    public int MaxProfit(int[] prices, int fee) {
        int hold = -prices[0];
        int lose = Math.Max(0,-fee);
        for(int i=1;i<prices.Length;i++){
            int a = Math.Max(hold,lose-prices[i]);
            int b = Math.Max(lose,hold+prices[i]-fee);
            hold = a;
            lose = b;
        }
        return lose;
    }
}
```

## 13 并查集

### 13.1 概念

并查集（union&find）是一种树型的数据结构，用于处理一些不交集的合并及查询问题。

Find：确定元素属于哪一个子集，它可以被用来确定两个元素是否属于同一个子集。

Union：将两个子集合并为一个集合。

生活中的例子

- 小弟->老大（属于谁的手下

- 帮派识别
- 两种优化方式

并查集初始化：

```c#
public class QuickUnionUF{
	private int[] roots;
	public QuickUnionUF{
		roots = new int[n];
		for(int i=0;i<n;i++) 
            roots[i] = i;  //初始状态：我的老大是我本人，各自为营
	}
}
```

![image-20230104100500695](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104100500695.png)

操作：

```伪代码
//伪代码
function MakeSet(x)
	x.parent := x;
function Find(x)
	if x.parent ==x
		return x
	else
		return Find(x.parent)
fuction Union(x,y)
	xRoot := Find(x)
	yRoot := Find(y)
	xRoot.parent := yRoot
```

![image-20230104100521660](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104100521660.png)

### 13.2 优化方式

1）使树的总深度更低，从而提高查找效率

方式：在合并时选择较小深度树合并到较大深度树的合并方法。



![image-20230104100929302](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104100929302.png)

```伪代码
//深度：rank
fuction MakeSet(x)
	x.parent := x
	x.rank := 0
fuction Union(x,y)
	xRoot := Find(x)
	yRoot := Find(y)
	if xRoot == yRoot
		return
	if xRoot.rank < yRoot.rank
		xRoot.parent := yRoot
	else if xRoot.rank > yRoot.rank
		yRoot.parent := xRoot
	else 
		yRoot.parent := xRoot
		xRoot.rank := xRoot.rank + 1
```

2）路径压缩

![image-20230104101546972](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104101546972.png)

```c#
public class QuickUnionUF{
	private int[] roots;
	public QuickUnionUF(int n){
		roots = new int[n];
		for(int i=0;i<n;i++)
			roots[i] = i;
	}
	private int FindRoot(int i){
		int root = i;
		//找祖先
		while(root!=roots[root])
			root = roots[root];
		//路径压缩
		while(i!=roots[i]){
			int temp = roots[i];
			roots[i] = root;
			i = temp;
		}
		return root;
	}
	...
}
```

### 13.3 练习

#### 200 岛屿数量

##### DFS

```c#
public class Solution {
    public char[][] grid;
    public int NumIslands(char[][] g) {
        grid = g;
        int res = 0;
        for(int i=0;i<grid.Length;i++){
            for(int j=0;j<grid[0].Length;j++){
                if(grid[i][j]=='1'){
                    DFS(i,j);
                    res++;
                }
            }
        }
        return res;
    }
    private void DFS(int i,int j){
        if(i<0||j<0||i>=grid.Length||j>=grid[0].Length) return;
        if(grid[i][j]=='0') return;
        grid[i][j]='0';
        DFS(i-1,j);
        DFS(i+1,j);
        DFS(i,j-1);
        DFS(i,j+1);
    }
}
```

##### 并查集

```c#
public class QuickUnionUF{
    private int[] roots;   //祖先
    private int[] ranks;   //深度
    private int count;     //连通分量数目
    public QuickUnionUF(char[][] grid){
        int m = grid.Length;
        int n = grid[0].Length;
        roots = new int[m*n];
        ranks = new int[m*n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    roots[i*n+j] = i*n+j;
                    count++;
                }
            }
        }
    }
    public int FindRoot(int n){
        if(roots[n]!=n) return FindRoot(roots[n]);
        return n;
    }
    public void Union(int x,int y){
        int xRoot = FindRoot(x);
        int yRoot = FindRoot(y);
        if(xRoot!=yRoot){
            if(ranks[xRoot]<ranks[yRoot]) roots[xRoot] = yRoot;
            else if(ranks[xRoot]>ranks[yRoot]) roots[yRoot] = xRoot;
            else{
                roots[yRoot] = xRoot;
                ranks[xRoot]++;
            }
            count--;
        }
    }
    public int GetCount(){
        return count;
    }
}
public class Solution {
    public int NumIslands(char[][] grid) {
        QuickUnionUF uf = new QuickUnionUF(grid);
        int m = grid.Length;
        int n = grid[0].Length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    if(i-1>=0&&grid[i-1][j]=='1') uf.Union((i-1)*n+j,i*n+j);
                    if(i+1<m&&grid[i+1][j]=='1') uf.Union((i+1)*n+j,i*n+j);
                    if(j-1>=0&&grid[i][j-1]=='1') uf.Union(i*n+j-1,i*n+j);
                    if(j+1<n&&grid[i][j+1]=='1') uf.Union(i*n+j+1,i*n+j);
                }
            }
        }
        return uf.GetCount();
    }
}
```

#### 547 省份数量

```c#
public class QuickUnionUF{
    public int[] roots;
    public int[] ranks;
    public int count;
    public QuickUnionUF(int n){
        roots = new int[n];
        ranks = new int[n];
        for(int i=0;i<n;i++){
            roots[i] = i;
            count++;
        }
    }
    public int FindRoot(int n){
        if(roots[n]!=n) return FindRoot(roots[n]);
        return n;
    }
    public void Union(int x,int y){
        int xRoot = FindRoot(x);
        int yRoot = FindRoot(y);
        if(xRoot!=yRoot){
            if(ranks[xRoot]<ranks[yRoot]) roots[xRoot] = yRoot;
            else if(ranks[xRoot]>ranks[yRoot]) roots[yRoot] = xRoot;
            else{
                roots[yRoot] = xRoot;
                ranks[xRoot]++;
            } 
            count--;
        }

    }
}
public class Solution {
    public int FindCircleNum(int[][] isConnected) {
        int n = isConnected.Length;
        QuickUnionUF uf = new QuickUnionUF(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i!=j&&isConnected[i][j]==1){
                    uf.Union(i,j);
                }
            }
        }
        return uf.count;
    }
}
```

#### 990 等式方程的可满足性

```c#
public class QuickUnionUF{
    private int[] roots;   //祖先
    private int[] ranks;   //深度
    public QuickUnionUF(){
        roots = new int[26];
        ranks = new int[26];
        for(int i=0;i<26;i++)
            roots[i] = i;
    }
    public int FindRoot(int n){
        if(roots[n]!=n) return FindRoot(roots[n]);
        return n;
    }
    public void Union(int m,int n){
        int mRoot = FindRoot(m);
        int nRoot = FindRoot(n);
        if(ranks[mRoot]<ranks[nRoot]) roots[mRoot] = nRoot;
        else if(ranks[mRoot]>ranks[nRoot]) roots[nRoot] = mRoot;
        else{
            roots[mRoot] = nRoot;
            ranks[nRoot]++;
        }
    }
}
public class Solution {
    public bool EquationsPossible(string[] equations) {
        QuickUnionUF uf = new QuickUnionUF();
        for(int i=0;i<equations.Length;i++){
            int a = equations[i][0]-'a';
            int b = equations[i][3]-'a';
            if(equations[i][1]=='=') uf.Union(a,b);
            else if(uf.FindRoot(a)==uf.FindRoot(b)) return false;
        }
        for(int i=0;i<equations.Length;i++)
            if(equations[i][1]=='!'&&(uf.FindRoot(equations[i][0]-'a')==uf.FindRoot(equations[i][3]-'a')))
                return false;
        return true;
    }
}
```

#### 399 除法求值

```c#
public class Solution {
    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {
        QuickUnionUF uf = new QuickUnionUF(equations,values);
        double[] result = new double[queries.Count];
        for(int i=0;i<queries.Count;i++){
            string a = queries[i][0];
            string b = queries[i][1];
            if(!uf.roots.ContainsKey(a)||!uf.roots.ContainsKey(b)){
                result[i] = -1.0;
            }else{
                if(uf.FindRoot(a)!=uf.FindRoot(b)){
                    result[i] = -1.0;
                }else{
                    result[i] = uf.relation[a]/uf.relation[b];
                }
            }
        }
        return result;
    }
    private class QuickUnionUF{
        public Dictionary<string,string> roots;  
        public Dictionary<string,double> relation;
        public QuickUnionUF(IList<IList<string>> equations, double[] values){
            roots = new Dictionary<string,string>();
            relation = new Dictionary<string,double>();
            for(int i=0;i<equations.Count;i++){
                string a = equations[i][0];
                string b = equations[i][1];
                if(roots.ContainsKey(a)&&roots.ContainsKey(b)){
                    if(FindRoot(a)!=FindRoot(b)){
                        Union(a,b,values[i]);
                    }
                }else if(roots.ContainsKey(a)){
                    roots.Add(b,a);
                    relation.Add(b,1/values[i]);
                    string res = FindRoot(b);
                }else if(roots.ContainsKey(b)){
                    roots.Add(a,b);
                    relation.Add(a,values[i]);
                    string res = FindRoot(a);
                }else{
                    roots.Add(a,b);
                    relation.Add(a,values[i]);
                    roots.Add(b,b);
                    relation.Add(b,1);
                }
            }
        }
        public string FindRoot(string a){
            Stack<string> stack = new Stack<string>();
            //1.找祖先
            while(roots[a]!=a){
                stack.Push(a);
                a = roots[a];
            }
            //2.路径压缩
            while(stack.Count>0){
                string temp = stack.Pop();
                relation[temp] = relation[temp]*relation[roots[temp]];
                roots[temp] = a;
            }
            return a;
        }
        public void Union(string a,string b,double value){
            string aRoot = FindRoot(a);
            string bRoot = FindRoot(b);
            roots[aRoot] = bRoot;
            relation[aRoot] = value/relation[a]*relation[b];
            string res = FindRoot(a);
        }
    }
}
```

## 14 LRU Cache

### 14.1 概念

#### 1 Cache 缓存

- 记忆
- 钱包、储物柜（容量比较小
- 代码模块

#### 2 CPU Socket

三级缓存。

![image-20230104121807034](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104121807034.png)

#### 3 LRU Cache

- Least Recently Used（最近最少使用页面置换算法）（最近用的是啥）
- Double LinkedList（数据结构
- O(1) 查询（因为Cache一般查最前面的，所以就是O(1)，并不是说查所有元素都是O(1)
- O(1) 修改、更新

![image-20230104122138404](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104122138404.png)

#### 4 LFU Cache

- Least Frequently Used（最近最不常用页面置换算法）（频次）
- 注意F替换掉E的时候，说明优先级还是有考虑最近查找的元素

![image-20230104122543841](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104122543841.png)

### 14.2 练习

#### 146 LRU缓存

```c#
public class LRUCache {
    public class LinkedListNode{
        public int key;
        public int value;
        public LinkedListNode pre;
        public LinkedListNode next;
        public LinkedListNode(){}
        public LinkedListNode(int key,int value){this.key = key; this.value = value;}
    }
    int capacity;
    int size;
    public LinkedListNode first,last;
    Dictionary<int,LinkedListNode> dict;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        first = new LinkedListNode();
        last = new LinkedListNode();
        first.next = last;
        last.pre = first;
        dict = new Dictionary<int,LinkedListNode>();
    }
    
    public int Get(int key) {
        if(dict.ContainsKey(key)){
            Delete(key);
            ToFirst(key);
            return dict[key].value;
        }
        return -1;
    }
    
    public void Put(int key, int value) {
        if(dict.ContainsKey(key)){
            LinkedListNode cur = dict[key];
            cur.value = value;
            Delete(key);
            ToFirst(key);
        }else{
            LinkedListNode cur = new LinkedListNode(key,value);
            dict.Add(key,cur);
            ToFirst(key);
            if(size==capacity){
                int temp = last.pre.key;
                Delete(temp);
                dict.Remove(temp);
            }else{
                size++;
            }
        }
    }

    private void Delete(int key){
        LinkedListNode cur = dict[key];
        cur.pre.next = cur.next;
        cur.next.pre = cur.pre;
    }

    private void ToFirst(int key){
        LinkedListNode cur = dict[key];
        cur.next = first.next;
        first.next.pre = cur;
        first.next = cur;
        cur.pre = first;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.Get(key);
 * obj.Put(key,value);
 */
```

## 15 布隆过滤器

Bloom Filter。

一个很长的二进制向量和一个映射函数。

用来检索一个元素是否在一个集合中，如果它检索一个元素不在一个集合中，那么这个元素100%不在这个集合中，但如果它检索一个元素在一个集合中，那么这个元素**有概率不在**这个集合中。

它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

![image-20230104153043316](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104153043316.png)

将元素按映射函数映射到二进制向量的相应位。

w：按映射函数检索，发现有一位不为1，那么w这个元素一定不在该集合中，但如果都为1，不一定代表这个元素在（有可能是其他元素的映射）。

# Game Class

数据结构与算法。

## 1 图论

### 1.1 组成

- 顶点（Vertex
- 边（Edge
- 邻接点（无向图
- 度（与顶点相关联的边的数目
  - 入度
  - 出度

### 1.2 图的存储

- 邻接矩阵

  - ```
    int[,] Graph;
    ```

- 邻接表

  - ```
    Dictionary<int,List<int>> Graph;
    ```

![image-20230104220341382](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104220341382.png)

### 1.3 回路

#### 1 欧拉回路

从一个点出发，刚好**经过每条边一次**，然后回到原点，每个点要有进有出，即每个点的度必须是偶数。

eg：一笔画问题。

#### 2 汉密尔顿回路

从一个点出发，沿着边走，刚好**经过每个顶点一次**，之后回到出发点。

### 1.4 拓扑排序

有向无环图里所有顶点的线性序列，其中：

- 所有顶点出现且只出现一次
- 若存在一条A->B的路径，序列中A一定在B前面

![image-20230104210702597](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104210702597.png)

如何找拓扑排序：

- 从图里选择一个没有前驱（入度为0）的顶点
- 从该图中删除该顶点和以它为起点的有向边

每个有向无环图有一个或多个拓扑排序。

### 1.5 练习

#### 1791 找出星型图的中心节点

```c#
public class Solution {
    public int FindCenter(int[][] edges) {
        return (edges[0][0]==edges[1][0])||(edges[0][0]==edges[1][1])? edges[0][0]:edges[0][1];
    }
}
```

#### 997 找到小镇的法官

```c#
public class Solution {
    public int FindJudge(int n, int[][] trust) {
        int[] res = new int[n+1];
        for(int i=0;i<trust.Length;i++){
            res[trust[i][0]] = -1;
            if(res[trust[i][1]]==-1) continue;
            else res[trust[i][1]]++;
        }
        for(int i=1;i<=n;i++){
            if(res[i]==n-1) return i;
        }
        return -1;
    }
}
```

#### LCP07 传递消息

```c#
public class Solution {
    public int NumWays(int n, int[][] relation, int k) {
        //dp[i]表示传递到i需要几轮，dp[i]=All(dp[j]) j:所有一步到达i的人
        int[] dp = new int[n];
        for(int i=0;i<relation.Length;i++) if(relation[i][0]==0) dp[relation[i][1]]=1;
        for(int i=1;i<k;i++){
            int[] temp = new int[n];
            for(int j=0;j<relation.Length;j++){
                int a = relation[j][0];
                int b = relation[j][1];
                temp[b]+=dp[a];
            }
            dp = temp;
        }
        return dp[n-1];
    }
}
```

#### 2101 引爆最多的炸弹

```c#
public class Solution {
    public int[][] bombs;
    public List<List<int>> list;      //list[0]:第0号炸弹可以引爆的炸弹
    public int MaximumDetonation(int[][] bombs) {
        this.bombs = bombs;
        list = new List<List<int>>();
        //先算每一颗炸弹都能引爆什么炸弹
        for(int i=0;i<bombs.Length;i++){
            List<int> temp = new List<int>();
            for(int j=0;j<bombs.Length;j++){
                if(i!=j&&CanIDetonateJ(i,j)){
                    temp.Add(j);
                }
            }
            list.Add(temp);
        }
        int res = 0;
        for(int i=0;i<bombs.Length;i++){
            res = Math.Max(res,BFS(i));
        }
        return res;
    }
    private bool CanIDetonateJ(int i,int j){
        long a = bombs[i][0]-bombs[j][0];
        long b = bombs[i][1]-bombs[j][1];
        double dis = Math.Sqrt(a*a+b*b);
        if((double)bombs[i][2]>=dis) return true;
        return false;
    }
    private int BFS(int n){
        //是否已经引爆
        bool[] state = new bool[bombs.Length];
        state[n] = true;
        int count = 0;
        Queue<int> queue = new Queue<int>();
        queue.Enqueue(n);
        while(queue.Count!=0){
            int b = queue.Count;
            while(b>0){
                int temp = queue.Dequeue();
                count++;
                for(int i=0;i<list[temp].Count;i++){
                    if(!state[list[temp][i]]){
                        queue.Enqueue(list[temp][i]);
                        state[list[temp][i]] = true;
                    }
                }
                b--;
            }
        }
        return count;
    }
}
```

#### 207 课程表

```c#
public class Solution {
    public bool CanFinish(int numCourses, int[][] prerequisites) {
        int[] count = new int[numCourses];                                 //入度统计
        Dictionary<int,List<int>> dict = new Dictionary<int,List<int>>();  //dict[0]:0可以到达的数字的列表
        for(int i=0;i<prerequisites.Length;i++){
            int pre = prerequisites[i][1];
            int next = prerequisites[i][0];
            count[next]++;
            if(!dict.ContainsKey(pre)) dict.Add(pre,new List<int>());
            dict[pre].Add(next);
        }
        //拓扑排序
        bool[] delete = new bool[numCourses];
        while(true){
            //删除入度为0的结点以及以它为起点的边
            bool exist = false;
            for(int i=0;i<numCourses;i++){
                if(count[i]==0&&!delete[i]){
                    exist = true;
                    delete[i] = true;
                    if(dict.ContainsKey(i)){
                        for(int j=0;j<dict[i].Count;j++){
                            count[dict[i][j]]--;
                        }
                    }
                }
            }
            if(!exist) break;
        }
        for(int i=0;i<numCourses;i++) if(count[i]!=0) return false;
        return true;
    }
}
```

#### 1584 连接所有点的最小费用

prim算法。

```c#
public class Solution {
    public int[][] points;
    public int MinCostConnectPoints(int[][] points) {
        this.points = points;
        int[,] dis = new int[points.Length,points.Length];
        for(int i=0;i<points.Length;i++){
            for(int j=i+1;j<points.Length;j++){
                int temp = Distance(i,j);
                dis[i,j] = temp;
                dis[j,i] = temp;
            }
        }
        bool[] state = new bool[points.Length];
        int res = 0;
        state[0] = true;
        while(true){
            int min = 0;
            int minNum = 0;
            bool exist = false;
            for(int i=0;i<state.Length;i++){
                if(state[i]){
                    for(int j=0;j<state.Length;j++){
                        if(!state[j]&&(min==0||(min!=0&&min>dis[i,j]))){
                            exist = true;
                            min = dis[i,j];
                            minNum = j;
                        }
                    }
                }
            }
            if(exist){
                res+=min;
                state[minNum] = true;
            }else break;
        }
        return res;
    }
    private int Distance(int i,int j){
        int a = Math.Abs(points[i][0]-points[j][0]);
        int b = Math.Abs(points[i][1]-points[j][1]);
        return a+b;
    }
}
```

### 1.6 最小生成树

最小生成树使图联通并且所有边的权值之和最小。

![image-20230104220908055](C:\Users\97000\Desktop\春招\笔记\assets\image-20230104220908055.png)

#### 1 Prim算法

- 从任意节点出发来寻找最小生成树
- 某个点加入到被选取的点中后，解锁这个点出发的所有新的边
- 在所有解锁的边中选最小的边，然后看看这个边会不会形成环
- 如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）
- 如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2
- 当所有点都被选取，最小生成树就得到了

#### 2 Kruskal算法

- 总是从权值最小的边开始考虑，依次考察权值依次变大的边
- 当前的边要么进入最小生成树的集合，要么丢弃
- 如果当前的边进入最小生成树的集合中不会形成环，就要当前边
- 如果当前的边进入最小生成树的集合中会形成环，就不要当前边
- 考察完所有边之后，最小生成树的集合也得到了

### 1.7 练习

#### 1584 连接所有点的最小费用

##### Prim算法

```c#
public class Solution {
    public int[][] points;
    public int[] distance;
    public int MinCostConnectPoints(int[][] points) {
        this.points = points;
        distance = new int[points.Length];
        int con = int.MaxValue;
        for(int i=0;i<points.Length;i++) distance[i] = con;
        int k = 0;
        int res = 0;
        int n = points.Length-1;
        while(n>0){
            distance[k] = 0;
            int min = con;
            int minNum = 0;
            for(int i=0;i<points.Length;i++){
                distance[i] = Math.Min(distance[i],Calculation(k,i));
                if(distance[i]!=0&&distance[i]<min){
                    min = distance[i];
                    minNum = i;
                }
            }
            k = minNum;
            res+=min;
            n--;
        }
        return res;
    }
    private int Calculation(int m,int n){
        return Math.Abs(points[m][0]-points[n][0])+Math.Abs(points[m][1]-points[n][1]);
    }
}
```

##### Kruskal 算法+并查集+优先队列

```c#
public class QuickUnionUF{
    private int[] roots;
    private int[] ranks;
    public QuickUnionUF(int[][] points){
        roots = new int[points.Length];
        ranks = new int[points.Length];
        for(int i=0;i<roots.Length;i++) roots[i] = i;
    }
    public int FindRoot(int n){
        if(roots[n]!=n) return FindRoot(roots[n]);
        return n;
    }
    public bool IsConnect(int m,int n){
        if(FindRoot(m)==FindRoot(n)) return true;
        return false;
    }
    public void Union(int m,int n){
        int mRoot = FindRoot(m);
        int nRoot = FindRoot(n);
        if(ranks[mRoot]<ranks[nRoot]) roots[mRoot] = nRoot;
        else if(ranks[mRoot]>ranks[nRoot]) roots[nRoot] = mRoot;
        else{
            roots[mRoot] = nRoot;
            ranks[nRoot]++;
        }
    }
}
public class Solution {
    public int[][] points;
    public int MinCostConnectPoints(int[][] points) {
        //初始化
        this.points = points;
        int[,] distance = new int[points.Length,points.Length];
        PriorityQueue<int[], int> pq = new PriorityQueue<int[], int>();
        int k = 0;
        for(int i=0;i<points.Length;i++){
            for(int j=k;j<points.Length;j++){
                int temp = Calculation(i,j);
                distance[i,j] = temp;
                distance[j,i] = temp;
                pq.Enqueue(new int[]{i,j,temp},temp);
            }
            k++;
        }
        QuickUnionUF uf = new QuickUnionUF(points);
        int res = 0;
        while(pq.Count>0){
            int[] temp = pq.Dequeue();
            if(!uf.IsConnect(temp[0],temp[1])){
                res+=temp[2];
                uf.Union(temp[0],temp[1]);
            }
        }
        return res;
    }
    private int Calculation(int m,int n){
        return Math.Abs(points[m][0]-points[n][0])+Math.Abs(points[m][1]-points[n][1]);
    }
}
```

### 1.8 最短路径

某点到某点的最短路径。

#### 1 Floyd算法

特点：多源算法，一次性计算出所有点之间相互的最短距离，可以处理负权边。

Floyd算法的核心是动态规划，阐述为：i到j的最短距离要么等于i直接到j的距离，要么等于i间接到j的距离。

即：
$$
dis[i][j] = Math.Min(dis[i][j],dis[i][k]+dis[k][j]);
$$

```c#
for(int k=0;k<n;k++){
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(dis[i][k]+dis[k][j]<dis[i][j]){
                dis[i][j] = dis[i][k]+dis[k][j];
                path[i][j] = path[k][j];
            }
		}
	}
}
```

PS：

path数组应这样初始化：

![image-20230106220549377](C:\Users\97000\Desktop\春招\笔记\assets\image-20230106220549377.png)

#### 2 Bellman-Ford算法

特点：单源算法，动态规划，可以处理负权边。

松弛操作：只经过一条边可以到达哪些点。

![image-20230105153750406](C:\Users\97000\Desktop\春招\笔记\assets\image-20230105153750406.png)

#### 3 Dijkstra算法

单源算法，不可以处理负权边，因为dijkstra的本质是贪心，如果出现负权边，那么已经完成过最短路径更新的点可能被推翻。

不断选择离已经相连的点最近的点。

![image-20230105154753180](C:\Users\97000\Desktop\春招\笔记\assets\image-20230105154753180.png)

![image-20230105154940211](C:\Users\97000\Desktop\春招\笔记\assets\image-20230105154940211.png)

#### 4 区别

|              | **Floyd**              | **Bellman-Ford**       | **Dijkstra**           |
| ------------ | ---------------------- | ---------------------- | ---------------------- |
| 时间复杂度   | O(V3)                  | O(V*E)                 | O(V2)                  |
| 空间复杂度   | O(V2)                  | O(V)                   | O(V2)                  |
| 源数         | 多源                   | 单源                   | 单源                   |
| 负权处理能力 | 负权边  √  负权回路  × | 负权边  √  负权回路  × | 负权边  ×  负权回路  × |

### 1.9 练习

#### 787 K站中转内最便宜航班

##### Bellman-Ford算法

```c#
public class Solution {
    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        //Bellman-Ford算法
        //k站以内中转=走k+1条边=做k+1次松弛
        int[] dis = new int[n];
        int INF = 0x3f3f3f3f;
        for(int i=0;i<n;i++) dis[i] = INF;
        dis[src] = 0;
        while(k+1>0){
            int[] temp = new int[n];
            Array.Copy(dis,temp,dis.Length);
            foreach (int[] f in flights) {
                int x = f[0], y = f[1], w = f[2];
                dis[y] = Math.Min(dis[y], temp[x] + w);
            }
            k--;
        }
        if(dis[dst]!=INF) return dis[dst];
        return -1;
    }
}
```

#### 743 网络延迟时间

##### Dijkstra算法

```c#
public class Solution {
    public int NetworkDelayTime(int[][] times, int n, int k) {
        //单源Dijkstra算法
        int[] dis = new int[n];
        int INF = 0x3f3f3f3f;
        for(int i=0;i<n;i++) dis[i] = INF;
        dis[k-1] = 0;
        bool[] state = new bool[n];
        state[k-1] = true;
        int res = INF;
        while(true){
            int min = INF;
            int minNum = 0;
            int[] temp = new int[n];
            Array.Copy(dis,temp,n);
            foreach(int[] item in times){
                int a = item[0]-1,b = item[1]-1,value = item[2];
                if(state[a]&&!state[b]){
                    dis[b] = Math.Min(dis[b],temp[a]+value);
                    if(dis[b]<min){
                        min = dis[b];
                        minNum = b;
                    }
                }
            }
            if(min==INF) break;
            res = min;
            state[minNum] = true;
        }
        for(int i=0;i<n;i++) if(!state[i]) return -1;
        return res;
    }
}
```

### 1.10 A*

> https://blog.csdn.net/u014541881/article/details/127757135

#### 1 概念

A*算法是一种启发式搜索算法，是静态路网（网格图）中求解最短路径的最有效的直接搜索方法，是游戏里最常用的算法。

Dijkstra&A*

- Dijkstra的优化方向在于：从当前未完成最短路径更新的点中选择dis[i]最小的点，也就是说Dijkstra的优先级取决于dis[i]。
- 而A*的优先级公式为：f(n) = g(n) + h(n)。
  - g(n)：结点距离起点的代价
  - h(n)：结点距离终点的代价
  - 若h(n)=0，则A*退化为Dijkstra

![image-20230107135839831](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107135839831.png)

![image-20230107140115935](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140115935.png)

![image-20230107140337636](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140337636.png)

![image-20230107140324890](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140324890.png)

![image-20230107140349059](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140349059.png)

![image-20230107140359459](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140359459.png)

#### 2 算法过程

##### 无障碍

![image-20230107140437539](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140437539.png)

![image-20230107140450372](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140450372.png)

...

##### 有障碍

h(n)计算的时候不考虑障碍，就是离终点的直线距离。

![image-20230107140549065](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140549065.png)

![image-20230107140608859](C:\Users\97000\Desktop\春招\笔记\assets\image-20230107140608859.png)

### 1.11 贪心

贪心是一种思想。

用更少的纸币张数实现纸币找零，那么我会不断地选择当前能用的最大的纸币。

每次选择局部最优解，但是这样容易得到不正确的答案，且无法回退。

eg：Leetcode 122

如果后一天比前一天涨，那就前一天买入并在后一天卖出。

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107142710270.png" alt="image-20230107142710270" style="zoom:67%;" />

## 2 可视化迷宫

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107143550171.png" alt="image-20230107143550171" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107143559998.png" alt="image-20230107143559998" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107143607174.png" alt="image-20230107143607174" style="zoom:67%;" />

## 3 协程

格式

```c#
IEnumerator Text(){
	yield return null;                     //等待一Update帧
	yield return new WaitForSeconds(1f);   //等待一秒
	yield return new WaitForFixedUpdate(); //等待一FixedUpdate帧
	yield return new WaitForEndOfFrame();  //等待到这一帧结束
}
```

实现一个门缓缓移动

```c#
IEnumerator DoorOpen(){
	for(int i=0;i<60;i++){
		Door.transform.position += Vector3.right * 2/60f;
		yield return null;
	}
}
```

## 4 排序

### 4.1 稳定性

排序后，如果两个相等的数可以保持原先的顺序，即该排序算法具有稳定性。

### 4.2 评价指标

- 时间复杂度
- 辅助空间
  - 除了原先存储待排序数据的空间外，执行算法所需的空间。

### 4.3 插入排序

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107190733136.png" alt="image-20230107190733136" style="zoom: 67%;" />

```c#
int[] temp = new int[]{2,3,1};
//{}内为有序序列
//初始 {2},3,1
//一次 {2,3},1
//二次 {1,2,3}
```

```c#
int[] temp = new int[]{2,3,1};
for(int i=1;i<temp.Length;i++){
	int value = temp[i];
    int j = 0;
    for(j=i-1;j>=0;j--){
        if(temp[j]>value){
            temp[j+1] = temp[j];  //将元素往后移动
        }else{
            break;
        }
    }
    temp[j+1] = value;            //插入数据
}
```

**评价**

- 稳定

- 时间复杂度

  - $$
    1+2+3+...+(n-1)=\frac{n^2}{2}=O(n^2)
    $$

    

- 空间复杂度

  - O(1)

### 4.4 希尔排序

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107192012129.png" alt="image-20230107192012129" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107192103627.png" alt="image-20230107192103627" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107192114841.png" alt="image-20230107192114841" style="zoom:67%;" />

```c#
int[] temp = new int[]{2,3,1};
int gap = 1;  //计算增量
while(gap<temp.Length) gap = gap*3+1;
while(gap>0){
	for(int i=gap;i<temp.Length;i++){
		int b = temp[i];
		int a = i-gap;
		//分区间进行插入排序
		while(a>=0&&temp[a]>b){
			temp[a+gap] = temp[a];
			a-=gap;
		}
		temp[a+gap] = b;
	}
	gap/=3;
}
```

**评价**

- 不稳定

- 时间复杂度（取决于增量选择

  - $$
    O(n^{1.3...2})
    $$

- 空间复杂度
  - O(1)

### 4.5 冒泡排序

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107194020114.png" alt="image-20230107194020114" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107194030414.png" alt="image-20230107194030414" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107194043330.png" alt="image-20230107194043330" style="zoom:67%;" />

```c#
int[] temp = new int[]{2,3,1};
for(int i=0;i<temp.Length;i++){
    bool isSort = true;
	for(int j=0;j<temp.Length-1-i;j++){
		if(temp[j]>temp[j+1]){
			int tmp = temp[j];
			temp[j] = temp[j+1];
			temp[j+1] = tmp;
            isSort = false;
		}
	}
    if(isSort) break;
}
```

**评价**

- 稳定

- 时间复杂度

  - $$
    O(n^2)
    $$

- 空间复杂度
  - O(1)

### 4.6 快速排序

#### 1 基本快排

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232251261.png" alt="image-20230107232251261" style="zoom:67%;" />

**一轮排序**

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232420418.png" alt="image-20230107232420418" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232430017.png" alt="image-20230107232430017" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232439627.png" alt="image-20230107232439627" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232447497.png" alt="image-20230107232447497" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232455465.png" alt="image-20230107232455465" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232508377.png" alt="image-20230107232508377" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232516388.png" alt="image-20230107232516388" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232525228.png" alt="image-20230107232525228" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232534633.png" alt="image-20230107232534633" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232542934.png" alt="image-20230107232542934" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230107232551350.png" alt="image-20230107232551350" style="zoom:67%;" />

**代码**

```c#
public void QuickSort(int[] a,int left,int right){
	if(left>=right) return;
	int key = PartSort(a,left,right);  //排序
	QuickSort(a,left,key-1);           //对左区间进行递归调用
	QuickSort(a,key+1,right);          //对右区间进行递归调用
}
private int PartSort(int[] a,int low,int high){
	//选择第一个元素作为支点
	int num = a[low];
	//low和high没相遇时执行
	while(low<high){
		while(low<high&&a[high]>=num){
			high--;
		}
		a[low] = a[high];
		while(low<high&&a[low]<=num){
			low++;
		}
		a[high] = a[low];
	}
	a[low] = num;
	return low;
}
```

**评价**

- 不稳定
- 时间复杂度：O(nlogn)
  - 排序轮数取决于递归树的深度
  - 速度最快
- 空间复杂度：O(logn~n)
  - 递归树的深度

#### 2 快排优化

##### 1 随机基准

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230108001521381.png" alt="image-20230108001521381" style="zoom:67%;" />

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230108001532820.png" alt="image-20230108001532820" style="zoom:67%;" />

##### 2 三数取中

<img src="C:\Users\97000\Desktop\春招\笔记\assets\image-20230108001759075.png" alt="image-20230108001759075" style="zoom:67%;" />

### 4.7 练习

#### 452 用最少数量的箭引爆气球

##### PriorityQueue

```c#
public class Solution {
    public int FindMinArrowShots(int[][] points) {
        PriorityQueue<int[],int> queue = new PriorityQueue<int[],int>();
        foreach(int[] item in points) queue.Enqueue(item,item[1]);
        int res = 0;
        int[] a = queue.Dequeue();
        int num = a[1];
        res = 1;
        while(queue.Count>0){
            while(queue.Count>0){
                int[] temp = queue.Dequeue();
                if(num<temp[0]||num>temp[1]){
                    num = temp[1];
                    res++;
                    break;
                }
            }
        }
        return res;
    }
}
```

##### Array.Sort()

```c#
Array.Sort(points, (a, b) => {
    if(a[1]==b[1]) return 0;
    else return a[1]<b[1]? -1:1; //返回-1代表还按原来升序的原理进行排序
});
```

```c#
public class Solution {
    public int FindMinArrowShots(int[][] points) {
        Array.Sort(points,(a,b)=>{
            if(a[1]==b[1]) return 0;
            else return a[1]<b[1]? -1:1;
        });
        int res = 1;
        int num = points[0][1];
        for(int i=1;i<points.Length;i++){
            if(num<points[i][0]||num>points[i][1]){
                num = points[i][1];
                res++;
            }
        }
        return res;
    }
}
```

### 4.8 归并排序

思想：将两个或两个以上有序表合并成一个新的有序表。

![image-20230109214713390](assets/image-20230109214713390.png)

![image-20230109214719319](assets/image-20230109214719319.png)

```c#
private static void MergeSort(int[] arr,int length){
	int[] temp = new int[length];
	MergeInternalSort(arr,0,length,temp);
}
private static void MergeInternalSort(int[] arr,int first,int last,int[] temp){
	if(first<last){
		int mid = (first+last)/2;
		MergeInternalSort(arr,first,mid,temp);
		MergeInternalSort(arr,mid+1,last,temp);
		Merge(arr,first,mid,last,temp);
	}
}
private static void Merge(int[] arr,int mid,int last,int[] temp){
	int i = first;
	int j = mid+1;
	int k = 0;
	//通过比较，把较小的数放入到temp数组中
	while(i<=mid&&j<=last){
		if(arr[i]<arr[j]) temp[k++] = arr[i++];
		else temp[k++] = arr[j++];
	}
	//把剩余的放入到temp数组中
	while(i<=mid) temp[k++] = arr[i++];
	while(j<=last) temp[k++] = arr[j++];
	//把合并的数组结果赋值给原数组
	for(int m=0;m<k;m++){
		arr[m+first] = temp[m];
	}
}
```

**评价**

- 稳定
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

### 4.9 选择排序

![image-20230109220707044](assets/image-20230109220707044.png)

```c#
int[] temp = new int[]{2,1,3};
for(int i=0;i<temp.Length-1;i++){
	int minNum = i;
	for(int j=i+1;j<temp.Length;j++){
		if(temp[j]<temp[minNum]){
			minNum = j;
		}
	}
	if(minNum!=i){
		Swap(ref temp[i],ref temp[minNum]);
	}
}
```

**评价**

- 不稳定的（31 31 7：当7和第一个31交换，31的前后顺序被破坏

- 时间复杂度

  - $$
    O(n^2)
    $$

- 空间复杂度：O(1)

### 4.10 堆排序

基本思想：堆对应一棵完全二叉树，且所有非叶结点的值均不大于（或不小于）其子女的值，根结点（堆顶元素）的值是最小（或最大）的，每次都取堆顶的元素，将其放在序列最后面，然后将剩余的元素重新调整为最小（大）堆，依次类推，最终得到排序的序列。

堆排序分为大顶堆和小顶堆排序。**大顶堆**：堆对应一棵完全二叉树，且所有非叶结点的值均不小于其子女的值，**根结点（堆顶元素）的值是最大的**。而**小顶堆**正好相反，小顶堆：堆对应一棵完全二叉树，且所有非叶结点的值均不大于其子女的值，**根结点（堆顶元素）的值是最小的。**

实现堆排序需解决两个问题：

- 如何将n个待排序的数建成堆?
- 输出堆顶元素后，怎样调整剩余n-1个元素，使其成为一个新堆?

首先讨论第二个问题：输出堆顶元素后，怎样对剩余n-1元素重新建成堆？

调整小顶堆的方法：

- 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。
- 将根结点与左、右子树中较小元素的进行交换。
- 若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.
- 若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.
- 继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。

　　称这个自根结点到叶子结点的调整过程为筛选。如图：

![img](assets/v2-78c583e4be244a510d63cb5097b28152_720w.webp)

再讨论第一个问题，如何将n 个待排序元素初始建堆？建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。

- n 个结点的完全二叉树，则最后一个结点是第n/2个结点的子树。

- 筛选从第n/2个结点为根的子树开始，该子树成为堆。
- 之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。

　　如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）

![img](assets/v2-97ddf5ba52b9fe1ba68796437f89adfa_720w.webp)



![img](assets/v2-45736ec73d0b6d73657ac1320457ffe1_720w.webp)

```c#
//堆排序
//每次都取堆顶元素，将其放在序列最后，然后将剩余元素重新调整为大顶堆
public static void HeapSort(int[] arr,int length){
	CreateHeap(arr,length);
	//从最后的节点进行调整
	for(int i=length-1;i>0;i--){
		Swap(ref arr[0],ref arr[i]);
		//每次交换进行调整
		AdjustHeap(arr,0,i-1);
	}
}
//建堆方法
private static void CreateHeap(int[] arr,int length){
    //从最后一个非叶子节点开始进行堆调整
	for(int i=(length-2)/2;i>=0;i--){
		AdjustHeap(arr,i,length-1);
	}
}
//调整堆
private static void AdjustHeap(int[] arr,int start,int length){
	int root = start;
	int child = root*2+1;
	while(child<=length){
		//子节点指标在范围内才做比较
		if(child+1<=length&&arr[child]<arr[child+1]){
			//先比较两个子节点大小，选择最大的
			child++;
		}
		//如果父节点大于子节点代表调整完毕，直接跳出函数
		if(arr[root]>arr[child]) return;
		//否则交换父子内容再继续子节点和孙节点比较
		else{
			Swap[ref arr[root],ref arr[child]];
			root = child;
			child = root*2+1;
		}
	}
	
}
```

**评价**

- 不稳定
- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

### 4.11 练习

#### LCP30 魔塔游戏

```c#
public class Solution {
    public int MagicTower(int[] nums) {
        //先求总和
        //如果总和为负数，那么一定到不了最后一个房间；
        //如果总和为正数，一定到得了，此时考虑最少调整次数；
        long sum = 1;
        foreach(int item in nums) sum+=(long)item;
        if(sum<=0) return -1;
        PriorityQueue<int,int> queue = new PriorityQueue<int,int>();
        long blood = 1;
        int res = 0;
        foreach(int item in nums){
            if(item<0){
                queue.Enqueue(item,item);
                if(blood+(long)item<=0){
                    blood = blood+(long)item-(long)queue.Dequeue();
                    res++;
                }else blood+=(long)item;
            }else blood+=(long)item;
        }
        return res;
    }
}
```

#### 1094 拼车

```c#
public class Solution {
    public bool CarPooling(int[][] trips, int capacity) {
        //根据上车时间进行排序
        Array.Sort(trips, (a, b) => {
            if(a[1]==b[1]) return 0;
            else return a[1]<b[1]? -1:1; //返回-1代表还按原来升序的原理进行排序
        });
        //计算
        PriorityQueue<int[],int> queue = new PriorityQueue<int[],int>();
        foreach(int[] item in trips){
            //执行下车操作
            while(queue.Count!=0){
                int[] temp = queue.Peek();
                if(temp[1]<=item[1]){
                    queue.Dequeue();
                    capacity+=temp[0];
                }else break;
            }
            capacity-=item[0];
            if(capacity<0) return false;
            queue.Enqueue(new int[]{item[0],item[2]},item[2]);
        }
        return true;
    }
}
```

## 5 查找

在大量信息中找到特定信息。

### 5.1 顺序查找

从序列表的一端开始，依次把关键字和元素进行比较。

```c#
//特定元素：special
for(int i=0;i<nums.Length;i++){
	if(nums[i]==special) return i;
}
return -1;
```

### 5.2 二分查找

序列必须有序。

```
int BinarySearch(int[] nums,int low,int high,int target){
	if(low<=high){
		int mid = (low+high)/2;
		if(target<nums[mid]) return BinarySearch(nums,low,mid-1,target);
		else if(target>nums[mid]) return BinarySearch(nums,mid+1,high,target);
		else return mid;
	}
}
```

### 5.3 分块查找

分块有序。

比如：所有左边块元素<中间块元素<右边块元素。

<img src="assets/image-20230111175940943.png" alt="image-20230111175940943" style="zoom:67%;" />

### 5.4 查找树

#### 1 二叉查找树

<img src="assets/image-20230111180031153.png" alt="image-20230111180031153" style="zoom:67%;" />

二叉搜索树的中序遍历就是排序后的结果。

#### 2 四叉树

在一维的世界里，我们用二分查找。

二维的世界里，我们可以用四分查找，把屏幕分成四份，找不到就再分四份。

游戏开发里应用比较广泛，例如2d碰撞检测等。

<img src="assets/image-20230112115944402.png" alt="image-20230112115944402" style="zoom:67%;" />

<img src="assets/image-20230112115952940.png" alt="image-20230112115952940" style="zoom:67%;" />

<img src="assets/image-20230112120142870.png" alt="image-20230112120142870" style="zoom:67%;" />

#### 3 八叉树

<img src="assets/image-20230112120221327.png" alt="image-20230112120221327" style="zoom:67%;" />

### 5.5 哈希表

HashTable。

空间换时间。

#### 1 哈希函数的设计

将数值转换为索引。

##### 1 数字分析法

<img src="assets/image-20230112124033289.png" alt="image-20230112124033289" style="zoom:67%;" />

##### 2 平方取中法

<img src="assets/image-20230112124135889.png" alt="image-20230112124135889" style="zoom:67%;" />

##### 3 折叠法

<img src="assets/image-20230112124209143.png" alt="image-20230112124209143" style="zoom:67%;" />

##### 4 除留余数法

<img src="assets/image-20230112124254882.png" alt="image-20230112124254882" style="zoom:67%;" />

#### 2 解决冲突的方法

##### 1 链地址法

<img src="assets/image-20230112124353989.png" alt="image-20230112124353989" style="zoom:67%;" />

##### 2 开放地址法

<img src="assets/image-20230112124417966.png" alt="image-20230112124417966" style="zoom:67%;" />

<img src="assets/image-20230112124456899.png" alt="image-20230112124456899" style="zoom:67%;" />

<img src="assets/image-20230112124509252.png" alt="image-20230112124509252" style="zoom:67%;" />

### 5.6 滑动窗口

通常用于解决字符串问题。

![image-20230112125618832](assets/image-20230112125618832.png)

### 5.7 练习

#### 387 字符串中的第一个唯一字符

```c#
public class Solution {
    public int FirstUniqChar(string s) {
        Dictionary<int,int> dict = new Dictionary<int,int>();
        for(int i=0;i<s.Length;i++){
            //非唯一值将保存的索引值改为-1
            if(dict.ContainsKey(s[i])) dict[s[i]] = -1;
            else dict.Add(s[i],i);
        }
        int min = int.MaxValue;
        //找到除-1外索引值里最小的值，没有则返回-1
        foreach(var item in dict){
            if(item.Value!=-1) min = Math.Min(min,item.Value);
        }
        return min==int.MaxValue?-1:min;
    }
}
```

#### 219 存在重复元素Ⅱ

##### 字典

```c#
public class Solution {
    public bool ContainsNearbyDuplicate(int[] nums, int k) {
        Dictionary<int,int> dict = new Dictionary<int,int>();
        for(int i=0;i<nums.Length;i++){
            if(dict.ContainsKey(nums[i])){
                if(Math.Abs(dict[nums[i]]-i)<=k){
                    return true;
                }else dict[nums[i]] = i;
            }else dict.Add(nums[i],i);
        }
        return false;
    }
}
```

##### 滑动窗口+队列

```c#
public class Solution {
    public bool ContainsNearbyDuplicate(int[] nums, int k) {
        //k为窗口长度
        Queue<int> queue = new Queue<int>();
        for(int i=0;i<nums.Length;i++){
            if(queue.Count==k+1) queue.Dequeue();
            if(queue.Contains(nums[i])) return true;
            queue.Enqueue(nums[i]);
        }
        return false;
    }
}
```

#### 904 水果成篮

```c#
public class Solution {
    public int TotalFruit(int[] fruits) {
        //key-value：水果类型-摘取数目
        Dictionary<int,int> dict = new Dictionary<int,int>();
        int left = 0;
        int res = 0;
        int num = 0;
        for(int i=0;i<fruits.Length;i++){
            if(!dict.ContainsKey(fruits[i])){
                while(dict.Count==2){
                    dict[fruits[left]]--;
                    num--;
                    if(dict[fruits[left]]==0) dict.Remove(fruits[left]);
                    left++;
                }
                dict.Add(fruits[i],1);
            }else dict[fruits[i]]++;
            num++;
            res = Math.Max(res,num);
        }
        return res;
    }
}
```

